{
  "manifest": {
    "name": "mem",
    "version": "8.0.0",
    "description": "Memoize functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input",
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/sindresorhus/mem.git"
    },
    "funding": "https://github.com/sindresorhus/mem?sponsor=1",
    "author": {
      "name": "Sindre Sorhus",
      "email": "sindresorhus@gmail.com",
      "url": "https://sindresorhus.com"
    },
    "engines": {
      "node": ">=10"
    },
    "scripts": {
      "test": "xo && npm run build && tsd && ava",
      "build": "del-cli dist && tsc",
      "prepack": "npm run build"
    },
    "main": "dist",
    "types": "dist/index.d.ts",
    "files": [
      "dist/index.js",
      "dist/index.d.ts"
    ],
    "keywords": [
      "memoize",
      "function",
      "mem",
      "memoization",
      "cache",
      "caching",
      "optimize",
      "performance",
      "ttl",
      "expire",
      "promise"
    ],
    "dependencies": {
      "map-age-cleaner": "^0.1.3",
      "mimic-fn": "^3.1.0"
    },
    "devDependencies": {
      "@ava/typescript": "^1.1.1",
      "@sindresorhus/tsconfig": "^0.7.0",
      "@types/serialize-javascript": "^4.0.0",
      "ava": "^3.13.0",
      "del-cli": "^3.0.1",
      "delay": "^4.4.0",
      "serialize-javascript": "^5.0.1",
      "tsd": "^0.13.1",
      "typescript": "^4.0.3",
      "xo": "^0.33.1"
    },
    "ava": {
      "files": [
        "test.ts"
      ],
      "timeout": "1m",
      "typescript": {
        "rewritePaths": {
          "./": "dist/"
        }
      }
    },
    "xo": {
      "rules": {
        "@typescript-eslint/member-ordering": "off",
        "@typescript-eslint/no-var-requires": "off",
        "@typescript-eslint/no-empty-function": "off"
      }
    },
    "_registry": "npm",
    "_loc": "/home/vagrant/.cache/yarn/v5/npm-mem-8.0.0-b5e4b6d2d241c6296da05436173b4d0c7ae1f9ac/node_modules/mem/package.json",
    "readmeFilename": "readme.md",
    "readme": "# mem [![Build Status](https://travis-ci.com/sindresorhus/mem.svg?branch=master)](https://travis-ci.com/github/sindresorhus/mem)\n\n> [Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input\n\nMemory is automatically released when an item expires or the cache is cleared.\n\nBy default, **only the first argument is considered** and it only works with [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive). If you need to cache multiple arguments or cache `object`s *by value*, have a look at alternative [caching strategies](#caching-strategy) below.\n\n## Install\n\n```\n$ npm install mem\n```\n\n## Usage\n\n```js\nconst mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same argument\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the argument changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n\n// Only the first argument is considered by default\nmemoized('bar', 'foo');\n//=> 2\n```\n\n##### Works fine with promise returning functions\n\n```js\nconst mem = require('mem');\n\nlet i = 0;\nconst counter = async () => ++i;\nconst memoized = mem(counter);\n\n(async () => {\n\tconsole.log(await memoized());\n\t//=> 1\n\n\t// The return value didn't increase as it's cached\n\tconsole.log(await memoized());\n\t//=> 1\n})();\n```\n\n```js\nconst mem = require('mem');\nconst got = require('got');\nconst delay = require('delay');\n\nconst memGot = mem(got, {maxAge: 1000});\n\n(async () => {\n\tawait memGot('https://sindresorhus.com');\n\n\t// This call is cached\n\tawait memGot('https://sindresorhus.com');\n\n\tawait delay(2000);\n\n\t// This call is not cached as the cache has expired\n\tawait memGot('https://sindresorhus.com');\n})();\n```\n\n### Caching strategy\n\nBy default, only the first argument is compared via exact equality (`===`) to determine whether a call is identical.\n\n```js\nconst power = mem((a, b) => Math.power(a, b));\n\npower(2, 2); // => 4, stored in cache with the key 2 (number)\npower(2, 3); // => 4, retrieved from cache at key 2 (number), it's wrong\n```\n\nYou will have to use the `cache` and `cacheKey` options appropriate to your function. In this specific case, the following could work:\n\n```js\nconst power = mem((a, b) => Math.power(a, b), {\n  cacheKey: arguments_ => arguments_.join(',')\n});\n\npower(2, 2); // => 4, stored in cache with the key '2,2' (both arguments as one string)\npower(2, 3); // => 8, stored in cache with the key '2,3'\n```\n\nMore advanced examples follow.\n\n#### Example: Options-like argument\n\nIf your function accepts an object, it won't be memoized out of the box:\n\n```js\nconst heavyMemoizedOperation = mem(heavyOperation);\n\nheavyMemoizedOperation({full: true}); // Stored in cache with the object as key\nheavyMemoizedOperation({full: true}); // Stored in cache with the object as key, again\n// The objects look the same but for JS they're two different objects\n```\n\nYou might want to serialize or hash them, for example using `JSON.stringify` or something like [serialize-javascript](https://github.com/yahoo/serialize-javascript), which can also serialize `RegExp`, `Date` and so on.\n\n```js\nconst heavyMemoizedOperation = mem(heavyOperation, {cacheKey: JSON.stringify});\n\nheavyMemoizedOperation({full: true}); // Stored in cache with the key '[{\"full\":true}]' (string)\nheavyMemoizedOperation({full: true}); // Retrieved from cache\n```\n\nThe same solution also works if it accepts multiple serializable objects:\n\n```js\nconst heavyMemoizedOperation = mem(heavyOperation, {cacheKey: JSON.stringify});\n\nheavyMemoizedOperation('hello', {full: true}); // Stored in cache with the key '[\"hello\",{\"full\":true}]' (string)\nheavyMemoizedOperation('hello', {full: true}); // Retrieved from cache\n```\n\n#### Example: Multiple non-serializable arguments\n\nIf your function accepts multiple arguments that aren't supported by `JSON.stringify` (e.g. DOM elements and functions), you can instead extend the initial exact equality (`===`) to work on multiple arguments using [`many-keys-map`](https://github.com/fregante/many-keys-map):\n\n```js\nconst ManyKeysMap = require('many-keys-map');\n\nconst addListener = (emitter, eventName, listener) => emitter.on(eventName, listener);\n\nconst addOneListener = mem(addListener, {\n\tcacheKey: arguments_ => arguments_, // Use *all* the arguments as key\n\tcache: new ManyKeysMap() // Correctly handles all the arguments for exact equality\n});\n\naddOneListener(header, 'click', console.log); // `addListener` is run, and it's cached with the `arguments` array as key\naddOneListener(header, 'click', console.log); // `addListener` is not run again\naddOneListener(mainContent, 'load', console.log); // `addListener` is run, and it's cached with the `arguments` array as key\n```\n\nBetter yet, if your functionâ€™s arguments are compatible with `WeakMap`, you should use [`deep-weak-map`](https://github.com/futpib/deep-weak-map) instead of `many-keys-map`. This will help avoid memory leaks.\n\n## API\n\n### mem(fn, options?)\n\n#### fn\n\nType: `Function`\n\nFunction to be memoized.\n\n#### options\n\nType: `object`\n\n##### maxAge\n\nType: `number`\\\nDefault: `Infinity`\n\nMilliseconds until the cache expires.\n\n##### cacheKey\n\nType: `Function`\\\nDefault: `arguments_ => arguments_[0]`\\\nExample: `arguments_ => JSON.stringify(arguments_)`\n\nDetermines the cache key for storing the result based on the function arguments. By default, **only the first argument is considered**.\n\nA `cacheKey` function can return any type supported by `Map` (or whatever structure you use in the `cache` option).\n\nRefer to the [caching strategies](#caching-strategy) section for more information.\n\n##### cache\n\nType: `object`\\\nDefault: `new Map()`\n\nUse a different cache storage. Must implement the following methods: `.has(key)`, `.get(key)`, `.set(key, value)`, `.delete(key)`, and optionally `.clear()`. You could for example use a `WeakMap` instead or [`quick-lru`](https://github.com/sindresorhus/quick-lru) for a LRU cache.\n\nRefer to the [caching strategies](#caching-strategy) section for more information.\n\n### mem.clear(fn)\n\nClear all cached data of a memoized function.\n\n#### fn\n\nType: `Function`\n\nMemoized function.\n\n## Tips\n\n### Cache statistics\n\nIf you want to know how many times your cache had a hit or a miss, you can make use of [stats-map](https://github.com/SamVerschueren/stats-map) as a replacement for the default cache.\n\n#### Example\n\n```js\nconst mem = require('mem');\nconst StatsMap = require('stats-map');\nconst got = require('got');\n\nconst cache = new StatsMap();\nconst memGot = mem(got, {cache});\n\n(async () => {\n\tawait memGot('https://sindresorhus.com');\n\tawait memGot('https://sindresorhus.com');\n\tawait memGot('https://sindresorhus.com');\n\n\tconsole.log(cache.stats);\n\t//=> {hits: 2, misses: 1}\n})();\n```\n\n## Related\n\n- [p-memoize](https://github.com/sindresorhus/p-memoize) - Memoize promise-returning & async functions\n\n---\n\n<div align=\"center\">\n\t<b>\n\t\t<a href=\"https://tidelift.com/subscription/pkg/npm-mem?utm_source=npm-mem&utm_medium=referral&utm_campaign=readme\">Get professional support for this package with a Tidelift subscription</a>\n\t</b>\n\t<br>\n\t<sub>\n\t\tTidelift helps make open source sustainable for maintainers while giving companies<br>assurances about security, maintenance, and licensing for their dependencies.\n\t</sub>\n</div>\n",
    "licenseText": "MIT License\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npm.taobao.org/mem/download/mem-8.0.0.tgz?cache=0&sync_timestamp=1602347221281&other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Fmem%2Fdownload%2Fmem-8.0.0.tgz#b5e4b6d2d241c6296da05436173b4d0c7ae1f9ac",
    "type": "tarball",
    "reference": "https://registry.npm.taobao.org/mem/download/mem-8.0.0.tgz?cache=0&sync_timestamp=1602347221281&other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Fmem%2Fdownload%2Fmem-8.0.0.tgz",
    "hash": "b5e4b6d2d241c6296da05436173b4d0c7ae1f9ac",
    "integrity": "sha1-teS20tJBxiltoFQ2FztNDHrh+aw=",
    "registry": "npm",
    "packageName": "mem"
  },
  "registry": "npm",
  "hash": "b5e4b6d2d241c6296da05436173b4d0c7ae1f9ac"
}